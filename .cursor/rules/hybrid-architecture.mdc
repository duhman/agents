---
description: Hybrid deterministic/AI processing architecture patterns and best practices
globs: apps/agent/src/hybrid-processor.ts, apps/agent/src/simplified-processor.ts, apps/agent/src/metrics.ts
alwaysApply: false
---

# Hybrid Architecture Patterns

This rule documents the hybrid deterministic/AI processing approach used in the email automation system.

## Architecture Overview

The system uses a **deterministic-first, AI-fallback** strategy:

1. **Deterministic Processing**: Fast, free pattern matching for standard cases
2. **AI Fallback**: OpenAI for complex/ambiguous cases that need nuanced understanding
3. **Metrics Collection**: Track processing methods and performance
4. **Edge Case Detection**: Handle special scenarios with enhanced logic

## Deterministic-First Strategy

âœ… **DO:** Always try deterministic extraction first

```typescript
// From hybrid-processor.ts
let extraction = extractEmailDataDeterministic(rawEmail);
let extractionMethod: "deterministic" | "openai" = "deterministic";

// Only use OpenAI for complex cases
const needsOpenAI = 
  !extraction.confidence_factors.standard_case ||
  extraction.confidence_factors.clear_intent === false ||
  extraction.policy_risks.length > 1 ||
  (extraction.edge_case !== "none" && extraction.edge_case !== "sameie_concern");

if (needsOpenAI) {
  try {
    extraction = await extractWithOpenAI(maskedEmail, logContext);
    extractionMethod = "openai";
  } catch (error) {
    // Always fall back to deterministic
    logWarn("OpenAI extraction failed, falling back to deterministic", logContext);
  }
}
```

## Complex Case Detection

The system automatically detects when OpenAI is needed:

### Standard Cases (Deterministic)
- Clear cancellation intent
- Standard moving reason
- No edge cases
- Complete information
- Low policy risks

### Complex Cases (OpenAI Fallback)
- Unclear intent or ambiguous language
- Multiple policy risks
- Edge cases: corporate accounts, app access issues, future dates
- Incomplete information
- Non-standard scenarios

## Enhanced Extraction Schemas

âœ… **DO:** Use enhanced schemas with comprehensive edge case support

```typescript
export const extractionSchemaEnhanced = z.object({
  is_cancellation: z.boolean(),
  reason: z.enum(["moving", "other", "unknown"]),
  move_date: z.string().date().optional().nullable(),
  language: z.enum(["no", "en", "sv"]), // Swedish support
  edge_case: z.enum([
    "none", 
    "no_app_access", 
    "corporate_account", 
    "future_move_date", 
    "already_canceled", 
    "sameie_concern"
  ]),
  urgency: z.enum(["immediate", "future", "unclear"]),
  customer_concerns: z.array(z.string()).default([]),
  policy_risks: z.array(z.string()).default([]),
  confidence_factors: z.object({
    clear_intent: z.boolean(),
    complete_information: z.boolean(),
    standard_case: z.boolean()
  })
});
```

## Edge Case Detection

Handle special scenarios with pattern matching:

```typescript
function detectEdgeCase(email: string, extraction: ExtractionResult): string {
  const emailLower = email.toLowerCase();
  
  // Corporate account detection
  if (emailLower.match(/bedrift|corporate|company|business|firma/)) {
    return "corporate_account";
  }
  
  // App access issues
  if (emailLower.match(/ikke fungerer|not working|app.*problem|login.*issue/)) {
    return "no_app_access";
  }
  
  // Future move dates (>1 month)
  if (extraction.move_date && getMonthsFromNow(extraction.move_date) > 1) {
    return "future_move_date";
  }
  
  // Already canceled
  if (emailLower.match(/allerede.*oppsagt|already.*cancel|avsluttet|terminated/)) {
    return "already_canceled";
  }
  
  // Sameie concerns
  if (emailLower.match(/sameie|housing association|hele|everyone|whole building/)) {
    return "sameie_concern";
  }
  
  return "none";
}
```

## Enhanced Draft Generation

Use templates that handle edge cases:

```typescript
export function generateDraftEnhanced(params: EnhancedDraftParams): string {
  const { language, reason, moveDate, edgeCase, customerConcerns } = params;
  
  // Base template
  let body = getBaseTemplate(language);
  
  // Add reason-specific content
  if (reason === "moving") {
    body += getMovingContent(language);
  }
  
  // Handle edge cases
  if (edgeCase === "corporate_account") {
    body += getCorporateAccountContent(language);
  }
  
  if (edgeCase === "no_app_access") {
    body += getAppAccessContent(language);
  }
  
  // Add policy information
  body += getPolicyContent(language);
  
  // Add move date information
  if (moveDate) {
    body += getMoveDateContent(moveDate, language);
  }
  
  return body;
}
```

## Metrics Collection

âœ… **DO:** Track processing methods and performance

```typescript
// From metrics.ts
metricsCollector.record({
  extraction_method: extractionMethod,
  is_cancellation: extraction.is_cancellation,
  edge_case: extraction.edge_case,
  confidence,
  processing_time_ms: duration,
  policy_compliant: validation.compliant,
  language: extraction.language
});
```

## Language Support

Support multiple languages with detection:

```typescript
// Language detection with Swedish support
const norwegianIndicators = ['jeg', 'vi', 'du', 'har', 'til', 'med', 'og', 'en', 'er', 'pÃ¥'];
const swedishIndicators = ['jag', 'ska', 'vill', 'mitt', 'frÃ¥n', 'och', 'att', 'Ã¤r', 'fÃ¶r'];

let language: "no" | "en" | "sv";
if (norwegianCount >= 2) {
  language = "no";
} else if (swedishCount >= 2) {
  language = "sv";
} else {
  language = "en";
}
```

## Performance Benefits

### Deterministic Processing
- âš¡ **<500ms** processing time
- ðŸ’° **$0** API costs
- ðŸŽ¯ **100%** reliability
- ðŸ”§ **Easy** to debug and modify

### Hybrid Approach
- ðŸš€ **Best of both worlds**: Speed + accuracy
- ðŸ“Š **Metrics-driven**: Track when AI is needed
- ðŸ›¡ï¸ **Fallback safety**: Always works even if OpenAI fails
- ðŸ“ˆ **Cost optimization**: Only use AI when necessary

## Error Handling

Always provide fallback mechanisms:

```typescript
try {
  // Try OpenAI for complex cases
  extraction = await extractWithOpenAI(maskedEmail, logContext);
  extractionMethod = "openai";
} catch (error: any) {
  logWarn("OpenAI extraction failed, falling back to deterministic", logContext, {
    error: error.message
  });
  // Fall back to deterministic result
  extraction = extractEmailDataDeterministic(rawEmail);
  extractionMethod = "deterministic";
}
```

## Testing Strategy

Test both processing paths:

```typescript
// Test deterministic path
const standardEmail = "Hei, jeg skal flytte og vil si opp abonnementet mitt.";
const result = await processEmailHybrid({ source: "test", customerEmail: "test@example.com", rawEmail: standardEmail });
expect(result.extraction_method).toBe("deterministic");

// Test OpenAI fallback path
const complexEmail = "I'm not sure if I want to cancel, but I might be moving to a different country next year...";
const result2 = await processEmailHybrid({ source: "test", customerEmail: "test@example.com", rawEmail: complexEmail });
expect(result2.extraction_method).toBe("openai");
```

## References

- @apps/agent/src/hybrid-processor.ts - Main hybrid implementation
- @apps/agent/src/simplified-processor.ts - Pure deterministic fallback
- @apps/agent/src/metrics.ts - Performance metrics collection
- @packages/prompts/src/templates.ts - Enhanced schemas and templates
- @SIMPLIFICATION_SUMMARY.md - Architecture migration details