---
description: Slack HITM workflow patterns and interactive components with enhanced reliability
globs: apps/slack-bot/**/*.ts, api/slack/**/*.ts
alwaysApply: false
---

# Slack HITM (Human-in-the-Middle) Patterns

## Performance Constraints

‚ö†Ô∏è **Critical:** Slack webhooks timeout at 3 seconds

‚úÖ **DO:** Acknowledge immediately, process async
```typescript
app.action("approve", async ({ ack, body, client }) => {
  await ack(); // ‚úÖ Acknowledge first (<3s)
  
  // Then process async
  await processApproval(body);
});
```

‚ùå **DON'T:** Process before acknowledging
```typescript
app.action("approve", async ({ ack, body }) => {
  await processApproval(body); // ‚ùå May timeout
  await ack();
});
```

## Enhanced Reliability Patterns (2025)

‚úÖ **DO:** Use Vercel waitUntil for background tasks
```typescript
import { waitUntil } from "@vercel/functions";

// Fire and forget with proper Vercel handling
const slackTask = postReview(slackPayload).catch((error: unknown) => {
  log("error", "Slack posting failed", { error: parseErrorMessage(error) });
});

if (typeof waitUntil === "function") {
  waitUntil(slackTask);
} else {
  void slackTask; // Non-Vercel environments
}
```

‚úÖ **DO:** Implement Slack connectivity health checks
```typescript
async function testSlackConnectivity(token: string): Promise<SlackHealthCheck> {
  const startTime = Date.now();
  
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);
    
    const res = await fetch("https://slack.com/api/auth.test", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      },
      signal: controller.signal
    });
    
    clearTimeout(timeout);
    const responseTime = Date.now() - startTime;
    const result = await res.json();
    
    return {
      reachable: result.ok === true,
      responseTime,
      statusCode: res.status,
      timestamp: Date.now(),
      error: result.ok ? undefined : result.error
    };
  } catch (error: any) {
    return {
      reachable: false,
      responseTime: Date.now() - startTime,
      timestamp: Date.now(),
      error: error?.message || String(error)
    };
  }
}
```

‚úÖ **DO:** Implement retry queue for failed Slack posts
```typescript
interface SlackRetryItem {
  ticketId: string;
  draftId: string;
  channel: string;
  originalEmail: string;
  draftText: string;
  confidence: number;
  extraction: Record<string, any>;
  retryCount: number;
  nextRetryAt: number;
  createdAt: number;
}

async function queueSlackRetry(params: PostReviewParams): Promise<void> {
  const retryItem: SlackRetryItem = {
    ...params,
    retryCount: 0,
    nextRetryAt: Date.now() + 5 * 60 * 1000, // 5 minutes
    createdAt: Date.now()
  };
  
  slackRetryQueue.push(retryItem);
}
```

## Interactive Components

### Buttons with Metadata

Store context in button values as JSON:

```typescript
{
  type: "button",
  action_id: "approve",
  value: JSON.stringify({ ticketId, draftId, draftText })
}
```

‚ö†Ô∏è **Size guard:** Slack button `value` fields are limited to 2‚ÄØKB. If drafts can exceed ~1900 characters, trim before serializing or rely on server-side lookups (e.g., by ID) to avoid silent failures.

### Modals for Edits

Use modals for complex edits with `private_metadata`:

```typescript
await client.views.open({
  trigger_id: body.trigger_id,
  view: {
    type: "modal",
    callback_id: "edit_modal",
    private_metadata: JSON.stringify({ ticketId, draftId, channelId, messageTs }),
    blocks: [/* ... */]
  }
});
```

### Modal Timing Rules

üö® **When opening from a message button:**

- Call `views.open` synchronously within the 3‚ÄØs window. Keep any other work async (wrap in `void` self-executing functions).
- Only send the HTTP acknowledgement *after* `views.open` resolves. Responding first invalidates the trigger and the modal never appears.
- Always guard for missing `trigger_id`; fail fast and send a friendly thread message if modal launch fails.

### Reject Feedback Modal (2025)

When a reviewer clicks **Reject**, open a modal that captures a short rationale:

```typescript
const { view } = buildRejectModalView({
  ticketId,
  draftId,
  channelId,
  messageTs
});

await slackApi("views.open", { trigger_id: triggerId, view }, requestId);
```

- Require input (`response_action: "errors"`) if the field is empty.
- Trim input to 2000 characters to stay within Slack limits.
- Escape mrkdwn when echoing the reason.
- Update the original message to remove action buttons and show the rejection banner + quoted reason.

## Human Review Storage

Always log decisions to database:

```typescript
await createHumanReview({
  ticketId,
  draftId,
  decision: "approve" | "edit" | "reject",
  finalText: draftTextOrReason,
  reviewerSlackId: userId
});
```

- **Approve**: store the generated draft as `finalText`.
- **Edit**: store the reviewer-provided reply from the modal.
- **Reject**: store the rejection rationale (used later for training & QA).

## Message Formatting

‚úÖ **DO:** Use blocks for rich formatting
```typescript
blocks: [
  {
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*Confidence:* ${(confidence * 100).toFixed(0)}%`
    }
  }
]
```

## Error Handling

Always handle Slack API errors:

```typescript
try {
  await client.chat.postMessage({/* ... */});
} catch (error) {
  console.error("Slack API error:", error);
  // Fallback or retry logic
}
```

## References

- @apps/slack-bot/src/index.ts - HITM implementation
- @packages/db/src/repositories.ts - Human review storage
- @api/slack/interactions.ts - Modal + response handling
- @documentation/project/policies.md - Review policies
