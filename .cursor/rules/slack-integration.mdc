---
description: Slack HITM workflow patterns and interactive components with enhanced reliability
globs: apps/slack-bot/**/*.ts, api/slack/**/*.ts
alwaysApply: false
---

# Slack HITM (Human-in-the-Middle) Patterns

For the latest Slack platform documentation, reference [docs.slack.dev](https://docs.slack.dev) instead of the legacy `api.slack.com`. Key resources:
- [Slack App Manifest](https://docs.slack.dev/elements/manifests)
- [Block Kit Reference](https://docs.slack.dev/reference/block-kit)
- [Interactivity & Shortcuts](https://docs.slack.dev/surfaces/modals)
- [OAuth Scopes](https://docs.slack.dev/authentication/oauth-v2/scopes)
- [Web API Methods](https://docs.slack.dev/methods)

## Performance Constraints

‚ö†Ô∏è **Critical:** Slack webhooks timeout at 3 seconds
- Reference: [Interactivity best practices](https://docs.slack.dev/surfaces/modals#best-practices)

‚úÖ **DO:** Acknowledge immediately, process async

```typescript
app.action("approve", async ({ ack, body, client }) => {
  await ack(); // ‚úÖ Acknowledge first (<3s)

  // Then process async
  await processApproval(body);
});
```

‚ùå **DON'T:** Process before acknowledging

```typescript
app.action("approve", async ({ ack, body }) => {
  await processApproval(body); // ‚ùå May timeout
  await ack();
});
```

## Enhanced Reliability Patterns (2025)

‚úÖ **DO:** Use Vercel waitUntil for background tasks

```typescript
import { waitUntil } from "@vercel/functions";

// Fire and forget with proper Vercel handling
const slackTask = postReview(slackPayload).catch((error: unknown) => {
  log("error", "Slack posting failed", { error: parseErrorMessage(error) });
});

if (typeof waitUntil === "function") {
  waitUntil(slackTask);
} else {
  void slackTask; // Non-Vercel environments
}
```

‚úÖ **DO:** Implement Slack connectivity health checks

```typescript
async function testSlackConnectivity(token: string): Promise<SlackHealthCheck> {
  const startTime = Date.now();

  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);

    const res = await fetch("https://slack.com/api/auth.test", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json"
      },
      signal: controller.signal
    });

    clearTimeout(timeout);
    const responseTime = Date.now() - startTime;
    const result = await res.json();

    return {
      reachable: result.ok === true,
      responseTime,
      statusCode: res.status,
      timestamp: Date.now(),
      error: result.ok ? undefined : result.error
    };
  } catch (error: any) {
    return {
      reachable: false,
      responseTime: Date.now() - startTime,
      timestamp: Date.now(),
      error: error?.message || String(error)
    };
  }
}
```

‚úÖ **DO:** Implement database-backed retry queue for failed Slack posts

```typescript
// Queue failed post for retry
await createSlackRetryQueueItem({
  ticketId,
  draftId,
  channel,
  originalEmail,
  draftText,
  confidence: String(confidence),
  extraction,
  retryCount: '0',
  nextRetryAt: new Date(Date.now() + 5 * 60 * 1000) // 5 minutes
});
```

## Interactive Components

### Buttons with Metadata

Store context in button values as JSON:

```typescript
{
  type: "button",
  action_id: "approve",
  value: JSON.stringify({ ticketId, draftId, draftText })
}
```

‚ö†Ô∏è **Size guard:** Slack button `value` fields are limited to 2 KB. If drafts can exceed ~1900 characters, trim before serializing or rely on server-side lookups (e.g., by ID) to avoid silent failures.

### Modals for Edits

Use modals for complex edits with `private_metadata`:

```typescript
await client.views.open({
  trigger_id: body.trigger_id,
  view: {
    type: "modal",
    callback_id: "edit_modal",
    private_metadata: JSON.stringify({ ticketId, draftId, channelId, messageTs }),
    blocks: [/* ... */]
  }
});
```

### Modal Timing Rules

üö® **When opening from a message button:**

- Call `views.open` synchronously within the 3 s window. Keep any other work async (wrap in `void` self-executing functions).
- Only send the HTTP acknowledgement *after* `views.open` resolves. Responding first invalidates the trigger and the modal never appears.
- Always guard for missing `trigger_id`; fail fast and send a friendly thread message if modal launch fails.

### Reject Feedback Modal (2025)

When a reviewer clicks **Reject**, open a modal that captures a short rationale:

```typescript
const { view } = buildRejectModalView({
  ticketId,
  draftId,
  channelId,
  messageTs
});

await slackApi("views.open", { trigger_id: triggerId, view }, requestId);
```

- Require input (`response_action: "errors"`) if the field is empty.
- Trim input to 2000 characters to stay within Slack limits.
- Escape mrkdwn when echoing the reason.
- Update the original message to remove action buttons and show the rejection banner + quoted reason.

## Human Review Storage

Always log decisions to database:

```typescript
await createHumanReview({
  ticketId,
  draftId,
  decision: "approve" | "edit" | "reject",
  finalText: draftTextOrReason,
  reviewerSlackId: userId
});
```

- **Approve**: store the generated draft as `finalText`.
- **Edit**: store the reviewer-provided reply from the modal.
- **Reject**: store the rejection rationale (used later for training & QA).

## Message Formatting

‚úÖ **DO:** Use blocks for rich formatting

```typescript
blocks: [
  {
    type: "section",
    text: {
      type: "mrkdwn",
      text: `*Confidence:* ${(confidence * 100).toFixed(0)}%`
    }
  }
]
```

‚úÖ **DO:** Escape mrkdwn special characters

```typescript
function escapeMrkdwn(text: string): string {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
```

‚úÖ **DO:** Remove emojis from button text for accessibility

```typescript
{
  type: "button",
  text: { type: "plain_text", text: "Approve" },  // ‚úÖ No emoji
  style: "primary",
  action_id: "approve"
}
```

## Error Handling

Always handle Slack API errors with specific codes:

```typescript
try {
  await client.chat.postMessage({/* ... */});
} catch (error: any) {
  const errorCode = error?.data?.error || "unknown_error";

  switch (errorCode) {
    case "not_in_channel":
      log("error", "Bot not in channel", { channel, requestId });
      break;
    case "channel_not_found":
      log("error", "Channel not found", { channel, requestId });
      break;
    case "invalid_auth":
      log("error", "Invalid Slack token", { requestId });
      break;
    case "expired_trigger_id":
      log("error", "Trigger ID expired (>3s)", { requestId });
      break;
    case "rate_limited":
      const retryAfter = error?.data?.retry_after || 60;
      log("error", "Rate limited", { retryAfter, requestId });
      break;
    default:
      log("error", "Slack API error", { error: errorCode, requestId });
  }

  // Queue for retry
  await queueSlackRetry(params);
}
```

## Security

‚úÖ **DO:** Verify Slack signature for all webhook requests

Reference: [Request signing verification](https://docs.slack.dev/authentication/verifying-requests-from-slack)

```typescript
import { createHmac, timingSafeEqual } from "crypto";

function verifySlackSignature(req: VercelRequest, requestBody: string): boolean {
  const signingSecret = process.env.SLACK_SIGNING_SECRET;

  if (!signingSecret) {
    // Require explicit opt-in bypass in development
    if (process.env.ALLOW_INSECURE_SLACK_DEV !== "true") {
      log("error", "SLACK_SIGNING_SECRET not configured and ALLOW_INSECURE_SLACK_DEV not set");
      return false;
    }
    log("warn", "Slack signature verification disabled via ALLOW_INSECURE_SLACK_DEV");
    return true;
  }

  const slackSignature = req.headers["x-slack-signature"] as string | undefined;
  const slackTimestamp = req.headers["x-slack-request-timestamp"] as string | undefined;

  // Verify timestamp is recent (within 5 minutes) to prevent replay attacks
  const currentTime = Math.floor(Date.now() / 1000);
  const requestTime = parseInt(slackTimestamp, 10);

  if (Math.abs(currentTime - requestTime) > 60 * 5) {
    return false;
  }

  const sigBasestring = `v0:${slackTimestamp}:${requestBody}`;
  const computedSignature = `v0=${createHmac("sha256", signingSecret)
    .update(sigBasestring, "utf8")
    .digest("hex")}`;

  return timingSafeEqual(Buffer.from(slackSignature), Buffer.from(computedSignature));
}
```

## Rate Limiting

Properly handle Slack rate limits by respecting the `Retry-After` header:

```typescript
// Parse retry-after from headers or response body
function parseRetryAfterSeconds(
  headers: Headers,
  bodyRetryAfter?: unknown
): number | undefined {
  const headerValue = headers.get("retry-after");
  if (headerValue) {
    const parsed = parseInt(headerValue, 10);
    if (!Number.isNaN(parsed) && parsed > 0) return parsed;
  }

  const fallbackNumber =
    typeof bodyRetryAfter === "number"
      ? bodyRetryAfter
      : typeof bodyRetryAfter === "string"
        ? parseInt(bodyRetryAfter, 10)
        : undefined;

  if (fallbackNumber && fallbackNumber > 0) return fallbackNumber;
  return undefined;
}
```

Reference: [Rate limiting](https://docs.slack.dev/apis/rate-limiting)

## References

- @apps/slack-bot/src/index.ts - HITM implementation
- @apps/slack-bot/manifest.json - App manifest configuration
- @packages/db/src/repositories.ts - Human review storage
- @api/slack/interactions.ts - Modal + response handling
- @documentation/project/policies.md - Review policies
- SLACK_BOT_SETUP_GUIDE.md - Setup documentation
- [Slack Developer Docs](https://docs.slack.dev) - Official platform documentation
