---
description: Core architecture patterns for hybrid deterministic/AI processing with OpenAI best practices
globs: apps/agent/**/*.ts, packages/prompts/**/*.ts, apps/agent/src/metrics.ts
alwaysApply: false
---

# Core Architecture & OpenAI Patterns

This rule consolidates the hybrid deterministic/AI processing architecture with OpenAI best practices.

## Architecture Overview

The system uses a **deterministic-first, AI-fallback** strategy:

1. **Deterministic Processing**: Fast, free pattern matching for standard cases
2. **AI Fallback**: OpenAI for complex/ambiguous cases that need nuanced understanding
3. **Metrics Collection**: Track processing methods and performance
4. **Edge Case Detection**: Handle special scenarios with enhanced logic

## OpenAI API Best Practices (v5 - January 2025)

âœ… **DO:** Use main namespace (latest)

```typescript
import { zodResponseFormat } from "openai/helpers/zod";

const completion = await openai.chat.completions.parse({
  model: "gpt-4o-2024-08-06",
  messages: [
    /* ... */
  ],
  response_format: zodResponseFormat(extractionSchema, "extraction"),
  temperature: 0, // Deterministic for policy-critical tasks
  timeout: 30000 // 30s timeout
});

const parsed = completion.choices[0]?.message?.parsed;
if (!parsed) {
  throw new Error("Failed to parse extraction response from OpenAI");
}

return extractionSchema.parse(parsed);
```

âŒ **DON'T:** Use deprecated beta namespace

```typescript
// âŒ DEPRECATED - Will be removed
const completion = await openai.beta.chat.completions.parse({
  // ...
});
```

## Hybrid Processing Strategy

âœ… **DO:** Always try deterministic extraction first

```typescript
// From hybrid-processor.ts
let extraction = extractEmailDataDeterministic(rawEmail);
let extractionMethod: "deterministic" | "openai" = "deterministic";

// Only use OpenAI for complex cases
const needsOpenAI = 
  !extraction.confidence_factors.standard_case ||
  extraction.confidence_factors.clear_intent === false ||
  extraction.policy_risks.length > 1 ||
  (extraction.edge_case !== "none" && extraction.edge_case !== "sameie_concern");

if (needsOpenAI) {
  try {
    extraction = await extractWithOpenAI(maskedEmail, logContext);
    extractionMethod = "openai";
  } catch (error) {
    // Always fall back to deterministic
    logWarn("OpenAI extraction failed, falling back to deterministic", logContext);
  }
}
```

## Complex Case Detection

The system automatically detects when OpenAI is needed:

### Standard Cases (Deterministic)
- Clear cancellation intent
- Standard moving reason
- No edge cases
- Complete information
- Low policy risks

### Complex Cases (OpenAI Fallback)
- Unclear intent or ambiguous language
- Multiple policy risks
- Edge cases: corporate accounts, app access issues, future dates
- Incomplete information
- Non-standard scenarios

## Enhanced Extraction Schemas

âœ… **DO:** Use enhanced schemas with comprehensive edge case support

```typescript
export const extractionSchemaEnhanced = z.object({
  is_cancellation: z.boolean(),
  reason: z.enum(["moving", "other", "unknown"]),
  move_date: z.string().date().optional().nullable(),
  language: z.enum(["no", "en", "sv"]), // Swedish support
  edge_case: z.enum([
    "none", 
    "no_app_access", 
    "corporate_account", 
    "future_move_date", 
    "already_canceled", 
    "sameie_concern"
  ]),
  urgency: z.enum(["immediate", "future", "unclear"]),
  customer_concerns: z.array(z.string()).default([]),
  policy_risks: z.array(z.string()).default([]),
  confidence_factors: z.object({
    clear_intent: z.boolean(),
    complete_information: z.boolean(),
    standard_case: z.boolean()
  })
});
```

## Schema Patterns

âœ… **DO:** Use `.optional().nullable()` for optional fields (correct order)

```typescript
export const extractionSchema = z.object({
  move_date: z.string().date().optional().nullable(), // âœ… Correct order
  policy_risks: z.array(z.string()).default([])
});
```

âŒ **DON'T:** Use wrong order (will cause errors)

```typescript
move_date: z.string().date().nullable().optional(), // âŒ Wrong order
```

## Edge Case Detection

Handle special scenarios with pattern matching:

```typescript
function detectEdgeCase(email: string, extraction: ExtractionResult): string {
  const emailLower = email.toLowerCase();
  
  // Corporate account detection
  if (emailLower.match(/bedrift|corporate|company|business|firma/)) {
    return "corporate_account";
  }
  
  // App access issues
  if (emailLower.match(/ikke fungerer|not working|app.*problem|login.*issue/)) {
    return "no_app_access";
  }
  
  // Future move dates (>1 month)
  if (extraction.move_date && getMonthsFromNow(extraction.move_date) > 1) {
    return "future_move_date";
  }
  
  // Already canceled
  if (emailLower.match(/allerede.*oppsagt|already.*cancel|avsluttet|terminated/)) {
    return "already_canceled";
  }
  
  // Sameie concerns
  if (emailLower.match(/sameie|housing association|hele|everyone|whole building/)) {
    return "sameie_concern";
  }
  
  return "none";
}
```

## Enhanced Draft Generation

Use templates that handle edge cases:

```typescript
export function generateDraftEnhanced(params: EnhancedDraftParams): string {
  const { language, reason, moveDate, edgeCase, customerConcerns } = params;
  
  // Base template
  let body = getBaseTemplate(language);
  
  // Add reason-specific content
  if (reason === "moving") {
    body += getMovingContent(language);
  }
  
  // Handle edge cases
  if (edgeCase === "corporate_account") {
    body += getCorporateAccountContent(language);
  }
  
  if (edgeCase === "no_app_access") {
    body += getAppAccessContent(language);
  }
  
  // Add policy information
  body += getPolicyContent(language);
  
  // Add move date information
  if (moveDate) {
    body += getMoveDateContent(moveDate, language);
  }
  
  return body;
}
```

## Metrics Collection

âœ… **DO:** Track processing methods and performance

```typescript
// From metrics.ts
metricsCollector.record({
  extraction_method: extractionMethod,
  is_cancellation: extraction.is_cancellation,
  edge_case: extraction.edge_case,
  confidence,
  processing_time_ms: duration,
  policy_compliant: validation.compliant,
  language: extraction.language
});
```

## Retry Logic with Exponential Backoff

âœ… **DO:** Implement retry logic for OpenAI API calls

```typescript
import { withRetry } from "@agents/core";

const completion = await withRetry(
  async () => {
    return await openai.chat.completions.parse({
      model: "gpt-4o-2024-08-06",
      messages: [
        /* ... */
      ],
      response_format: zodResponseFormat(extractionSchema, "extraction"),
      temperature: 0,
      timeout: 30000
    });
  },
  3, // maxRetries
  1000 // baseDelay
);
```

**Retry Strategy:**
- Only retry on `rate_limit_exceeded` and `timeout` errors
- Exponential backoff: 1s, 2s, 4s delays
- Don't retry on quota/auth errors

## Error Handling (Enhanced)

Always handle OpenAI-specific error codes with structured logging:

```typescript
try {
  const completion = await openai.chat.completions.parse({
    // ... config
    timeout: 30000
  });

  const parsed = completion.choices[0]?.message?.parsed;
  if (!parsed) {
    throw new Error("Failed to parse extraction response from OpenAI");
  }

  return extractionSchema.parse(parsed);
} catch (error: any) {
  // Enhanced error handling with structured logging
  if (error.code === "insufficient_quota") {
    logError("OpenAI API quota exceeded", logContext, error);
    throw new Error("OpenAI API quota exceeded. Please check your billing.");
  } else if (error.code === "rate_limit_exceeded") {
    logError("OpenAI API rate limit exceeded", logContext, error);
    throw new Error("OpenAI API rate limit exceeded. Retry after delay.");
  } else if (error.code === "timeout") {
    logError("OpenAI API request timed out", logContext, error);
    throw new Error("OpenAI API request timed out. Please try again.");
  } else if (error.name === "ZodError") {
    logError("Schema validation error", logContext, error);
    throw new Error("Invalid extraction format from OpenAI");
  }

  logError("OpenAI extraction error", logContext, error);
  throw new Error(`Extraction failed: ${error.message || "Unknown error"}`);
}
```

## Language Support

Support multiple languages with detection:

```typescript
// Language detection with Swedish support
const norwegianIndicators = ['jeg', 'vi', 'du', 'har', 'til', 'med', 'og', 'en', 'er', 'pÃ¥'];
const swedishIndicators = ['jag', 'ska', 'vill', 'mitt', 'frÃ¥n', 'och', 'att', 'Ã¤r', 'fÃ¶r'];

let language: "no" | "en" | "sv";
if (norwegianCount >= 2) {
  language = "no";
} else if (swedishCount >= 2) {
  language = "sv";
} else {
  language = "en";
}
```

## Performance Benefits

### Deterministic Processing
- âš¡ **<500ms** processing time
- ðŸ’° **$0** API costs
- ðŸŽ¯ **100%** reliability
- ðŸ”§ **Easy** to debug and modify

### Hybrid Approach
- ðŸš€ **Best of both worlds**: Speed + accuracy
- ðŸ“Š **Metrics-driven**: Track when AI is needed
- ðŸ›¡ï¸ **Fallback safety**: Always works even if OpenAI fails
- ðŸ“ˆ **Cost optimization**: Only use AI when necessary

## Model Selection (January 2025)

- **Structured outputs**: `gpt-4o-2024-08-06` (current best)
- **Temperature**: `0` for deterministic, policy-critical extractions
- **Timeout**: `30000` (30s) for serverless environments
- **Fine-tuning**: `gpt-4o-mini-2024-07-18` (cost-effective)
- **OpenAI Version**: v5+ (latest with main namespace)

## Testing Strategy

Test both processing paths:

```typescript
// Test deterministic path
const standardEmail = "Hei, jeg skal flytte og vil si opp abonnementet mitt.";
const result = await processEmailHybrid({ source: "test", customerEmail: "test@example.com", rawEmail: standardEmail });
expect(result.extraction_method).toBe("deterministic");

// Test OpenAI fallback path
const complexEmail = "I'm not sure if I want to cancel, but I might be moving to a different country next year...";
const result2 = await processEmailHybrid({ source: "test", customerEmail: "test@example.com", rawEmail: complexEmail });
expect(result2.extraction_method).toBe("openai");
```

## Testing Strategy

Test both processing paths:

```typescript
// Test deterministic path
const standardEmail = "Hei, jeg skal flytte og vil si opp abonnementet mitt.";
const result = await processEmailHybrid({ source: "test", customerEmail: "test@example.com", rawEmail: standardEmail });
expect(result.extraction_method).toBe("deterministic");

// Test OpenAI fallback path
const complexEmail = "I'm not sure if I want to cancel, but I might be moving to a different country next year...";
const result2 = await processEmailHybrid({ source: "test", customerEmail: "test@example.com", rawEmail: complexEmail });
expect(result2.extraction_method).toBe("openai");
```

## Testing & Evaluation Best Practices

### Golden Set Testing

Maintain a golden set of test cases for regression testing:

```typescript
interface GoldenExample {
  email: string;
  expected: {
    is_cancellation: boolean;
    reason: string;
    language: string;
  };
}

const goldenSet: GoldenExample[] = [
  {
    email: "Hei, jeg skal flytte til Oslo 15. mars.",
    expected: {
      is_cancellation: true,
      reason: "moving",
      language: "no"
    }
  }
];
```

### Accuracy Metrics

Track key metrics:

- **Intent accuracy**: Cancellation vs. non-cancellation detection
- **Field extraction**: Reason, move date, language
- **Policy compliance**: End-of-month policy mentioned

```typescript
const accuracy = (correct / total) * 100;

if (accuracy < 90) {
  console.error("âœ— Accuracy below threshold (90%)");
  process.exit(1);
}
```

### PII Masking Tests

Always test PII masking:

```typescript
import { maskPII } from "@agents/core";

test("masks email addresses", () => {
  const input = "Contact me at test@example.com";
  const output = maskPII(input);
  expect(output).toBe("Contact me at [email]");
  expect(output).not.toContain("@example.com");
});
```

### Schema Validation Tests

Test Zod schemas with both valid and invalid inputs:

```typescript
import { extractionSchema } from "@agents/prompts";

test("validates extraction schema", () => {
  const valid = {
    is_cancellation: true,
    reason: "moving",
    move_date: "2024-03-15",
    language: "no",
    policy_risks: []
  };
  
  const result = extractionSchema.safeParse(valid);
  expect(result.success).toBe(true);
});
```

### Running Evaluations

Always run evaluation after prompt changes:

```bash
# After modifying packages/prompts/src/templates-enhanced.ts
pnpm eval
```

## References

- apps/agent/src/hybrid-processor.ts - Main hybrid implementation
- apps/agent/src/simplified-processor.ts - Pure deterministic fallback
- apps/agent/src/metrics.ts - Performance metrics collection
- packages/prompts/src/templates-enhanced.ts - Enhanced schemas and templates
- packages/core/src/index.ts - Retry logic and logging
- ops/scripts/eval.ts - Evaluation implementation
- SIMPLIFICATION_SUMMARY.md - Architecture migration details