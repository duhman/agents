---
description: Vercel serverless patterns, webhooks, logging, and deployment best practices (January 2025)
globs: api/**/*.ts, vercel.json
alwaysApply: false
---

# Vercel Serverless & API Patterns

This rule consolidates Vercel deployment patterns, webhook handling, structured logging, and serverless best practices.

## Function Runtime Configuration

✅ **DO:** Configure runtime and regions explicitly

```typescript
// Configure Vercel function runtime
export const config = {
  runtime: "nodejs",
  regions: ["iad1"] // Specify region closest to your database
};
```

✅ **DO:** Set appropriate timeouts in vercel.json

```json
{
  "functions": {
    "api/*.ts": {
      "maxDuration": 30
    },
    "api/cron/*.ts": {
      "maxDuration": 300
    }
  }
}
```

## Database Connection Pooling (Latest 2025)

✅ **DO:** Use optimized connection pooling for Vercel

```typescript
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";

const isServerless = process.env.VERCEL === "1" || process.env.AWS_LAMBDA_FUNCTION_NAME;

const queryClient = postgres(connectionString, {
  prepare: isServerless ? false : undefined,
  max: isServerless ? 1 : 10,
  idle_timeout: isServerless ? 20 : undefined,
  connect_timeout: 10,
  transform: {
    undefined: null // Transform undefined to null for PostgreSQL
  }
});

export const db = drizzle(queryClient, { schema });
```

❌ **DON'T:** Create connections outside request handlers

```typescript
// ❌ This will cause connection leaks
const db = drizzle(postgres(connectionString)); // Outside handler
```

## Fire-and-Forget Background Tasks

⚠️ **Critical:** Keep functions <30s execution time (updated limit)

✅ **DO:** Use Vercel waitUntil for background tasks

```typescript
import { waitUntil } from "@vercel/functions";

export default async function handler(req: VercelRequest, res: VercelResponse) {
  const requestId = generateRequestId();
  const logContext: LogContext = { requestId };

  // Process critical path first
  const result = await processEmail(data);

  // Fire-and-forget non-critical operations with proper Vercel handling
  const slackTask = postToSlack(result).catch((error: unknown) => {
    logError("Slack posting failed", logContext, error);
    // Don't fail the webhook if Slack fails
  });

  if (typeof waitUntil === "function") {
    waitUntil(slackTask);
  } else {
    void slackTask; // Non-Vercel environments
  }

  // Return immediately
  return res.status(200).json({ success: true, request_id: requestId });
}
```

## Webhook Input Validation

✅ **DO:** Validate required subject and body fields

```typescript
interface WebhookPayload {
  source?: string;
  customerEmail?: string;
  subject?: string;     // Required field
  body?: string;        // Required field
}

// Validate required fields
const subject = typeof body.subject === "string" ? body.subject : "";
const bodyText = typeof body.body === "string" ? body.body : "";

if (!subject && !bodyText) {
  return res.status(400).json({
    error: "validation: subject and body are required",
    request_id: requestId
  });
}

// Construct rawEmail format for internal processing only
const rawEmail = subject ? `Subject: ${subject}\n\n${bodyText}` : bodyText;
```

✅ **DO:** Log webhook validation details

```typescript
logInfo("Request validation successful", logContext, {
  source,
  subjectLength: subject.length,
  bodyLength: bodyText.length,
  subjectPreview: subject.slice(0, 50),
  bodyPreview: bodyText.slice(0, 50)
});
```

## Structured Logging (Production-Grade)

✅ **DO:** Use structured logging with request IDs

```typescript
import { logInfo, logError, logWarn, generateRequestId, type LogContext } from "@agents/core";

export default async function handler(req: VercelRequest, res: VercelResponse) {
  const requestId = generateRequestId(); // crypto.randomUUID()
  const logContext: LogContext = { requestId };
  const startTime = Date.now();

  try {
    logInfo("Webhook received", logContext, {
      method: req.method,
      url: req.url
    });

    // Process request...

    const duration = Date.now() - startTime;
    logInfo("Request completed", { ...logContext, duration });

    return res.status(200).json({
      success: true,
      request_id: requestId,
      processing_time_ms: duration
    });
  } catch (error: any) {
    const duration = Date.now() - startTime;
    logError("Request failed", { ...logContext, duration }, error);

    const statusCode = getErrorStatusCode(error);
    return res.status(statusCode).json({
      error: error.message || "Internal server error",
      request_id: requestId,
      processing_time_ms: duration
    });
  }
}
```

## Log Context Interface

✅ **DO:** Use consistent LogContext structure

```typescript
export interface LogContext {
  requestId: string;
  userId?: string;
  ticketId?: string;
  duration?: number;
  [key: string]: any;
}
```

## Error Handling & Status Codes

✅ **DO:** Return appropriate HTTP status codes

```typescript
function getErrorStatusCode(error: any): number {
  const message = error.message?.toLowerCase() || "";

  if (message.includes("quota")) return 402;
  if (message.includes("rate limit")) return 429;
  if (message.includes("timeout")) return 504;
  if (message.includes("validation")) return 400;
  if (message.includes("unauthorized")) return 401;
  if (message.includes("forbidden")) return 403;

  return 500;
}
```

✅ **DO:** Log errors with context and stack traces

```typescript
try {
  // API call...
} catch (error: any) {
  logError("OpenAI API error", logContext, error);
  // Error object includes: message, stack, code, etc.
}
```

❌ **DON'T:** Log raw customer data

```typescript
// ❌ NEVER log PII
logInfo("Processing email", logContext, {
  email: "customer@example.com" // ❌ Contains PII
});

// ✅ DO mask PII
logInfo("Processing email", logContext, {
  email: maskPII("customer@example.com") // ✅ Masked
});
```

## Retry Logic with Exponential Backoff

✅ **DO:** Implement retry logic for API calls

```typescript
import { withRetry } from "@agents/core";

const result = await withRetry(
  async () => {
    return await openai.chat.completions.parse({
      model: "gpt-4o-2024-08-06",
      messages: [/* ... */],
      response_format: zodResponseFormat(extractionSchema, "extraction"),
      temperature: 0,
      timeout: 30000
    });
  },
  3, // maxRetries
  1000 // baseDelay (exponential: 1s, 2s, 4s)
);
```

**Retry Strategy:**
- Only retry on `rate_limit_exceeded` and `timeout` errors
- Exponential backoff: 1s, 2s, 4s delays
- Don't retry on quota/auth errors

## Environment Variables & Security

✅ **DO:** Validate environment variables with Zod

```typescript
import { z } from "zod";

export const envSchema = z.object({
  DATABASE_URL: z.string().url(),
  OPENAI_API_KEY: z.string().min(1),
  SLACK_BOT_TOKEN: z.string().min(1).optional(),
  SLACK_SIGNING_SECRET: z.string().min(1).optional(),
  CRON_SECRET: z.string().min(1).optional()
});

const env = envSchema.parse(process.env);
```

## Request Validation

✅ **DO:** Validate webhook requests thoroughly

```typescript
// Minimal validation (avoid zod/types at edge)
const rawBody = typeof req.body === "string" ? JSON.parse(req.body) : req.body ?? {};
const body = (rawBody ?? {}) as WebhookPayload;
const source = typeof body.source === "string" && body.source ? body.source : "hubspot";
const customerEmail = typeof body.customerEmail === "string" && body.customerEmail
  ? body.customerEmail
  : "masked@example.com";

if (req.method !== "POST") {
  logWarn("Invalid HTTP method", { method: req.method, requestId }, logContext);
  res.status(405).json({ error: "Method not allowed" });
  return;
}
```

## Performance Monitoring

✅ **DO:** Track processing duration and log performance

```typescript
const startTime = Date.now();
const requestId = randomUUID();

// ... process request ...

const duration = Date.now() - startTime;
logInfo("Webhook processing completed successfully", {
  duration,
  success: result.success,
  ticketId: result.ticket?.id,
  draftId: result.draft?.id,
  confidence: result.confidence,
  route: result.route,
  requestId
});

res.status(200).json({
  success: result.success,
  ticket_id: result.ticket?.id,
  draft_id: result.draft?.id,
  confidence: result.confidence,
  route: result.route,
  request_id: requestId,
  processing_time_ms: duration
});
```

## Cron Jobs & Scheduled Functions

✅ **DO:** Protect cron endpoints with authentication

```typescript
export default async function handler(req: VercelRequest, res: VercelResponse) {
  // Verify cron secret to prevent unauthorized access
  const authHeader = req.headers.authorization;
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // Process cron job...
}
```

✅ **DO:** Define cron schedules in vercel.json

```json
{
  "crons": [
    {
      "path": "/api/cron/export-training-data",
      "schedule": "0 0 1 * *" // Monthly on 1st at midnight
    },
    {
      "path": "/api/cron/process-slack-retry",
      "schedule": "*/5 * * * *" // Every 5 minutes
    }
  ]
}
```

## Health Check Endpoints

✅ **DO:** Implement comprehensive health checks

```typescript
export default async function handler(req: VercelRequest, res: VercelResponse) {
  const startTime = Date.now();

  try {
    const [database, openai, slack] = await Promise.all([
      checkDatabase(),
      checkOpenAI(),
      checkSlack()
    ]);

    const duration = Date.now() - startTime;

    const health = {
      status: "healthy",
      timestamp: new Date().toISOString(),
      duration_ms: duration,
      services: { database, openai, slack },
      version: process.env.VERCEL_GIT_COMMIT_SHA || "local",
      environment: process.env.NODE_ENV || "development"
    };

    // Check if any service is unhealthy
    const unhealthyServices = Object.values(health.services).filter(
      service => service.status === "unhealthy"
    );

    if (unhealthyServices.length > 0) {
      health.status = "degraded";
      return res.status(503).json(health);
    }

    return res.status(200).json(health);
  } catch (error: any) {
    return res.status(500).json({
      status: "unhealthy",
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
}
```

## Vercel Configuration (vercel.json)

✅ **DO:** Configure comprehensive function settings

```json
{
  "buildCommand": "pnpm install && pnpm build",
  "functions": {
    "api/webhook.ts": {
      "maxDuration": 30
    },
    "api/health.ts": {
      "maxDuration": 10
    },
    "api/cron/export-training-data.ts": {
      "maxDuration": 300
    },
    "api/cron/process-slack-retry.ts": {
      "maxDuration": 60
    }
  },
  "regions": ["iad1"],
  "framework": null,
  "env": {
    "NODE_ENV": "production"
  },
  "crons": [
    {
      "path": "/api/cron/export-training-data",
      "schedule": "0 0 1 * *"
    },
    {
      "path": "/api/cron/process-slack-retry",
      "schedule": "*/5 * * * *"
    }
  ]
}
```

## References

- api/webhook.ts - Main webhook handler with latest patterns
- api/health.ts - Health check endpoint
- api/cron/export-training-data.ts - Cron example
- api/cron/process-slack-retry.ts - Retry queue processor
- packages/core/src/index.ts - Logging and validation utilities
- packages/db/src/client.ts - Database connection pooling
- vercel.json - Deployment configuration
- [Vercel Functions Documentation](https://vercel.com/docs/functions)
- [Vercel Connection Pooling Guide](https://vercel.com/guides/connection-pooling-with-functions)
